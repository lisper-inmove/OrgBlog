#+TITLE: Kong Plugin
#+DATE: 2023-09-27 22:25:01
#+DISPLAY: t
#+STARTUP: indent
#+OPTIONS: toc:10
#+AUTHOR: inmove
#+KEYWORDS: API网关 Kong
#+CATEGORIES: API网关

* HelloWorld
  1. 创建hello-world目录，添加handler.lua和schema.lua
  2. 创建kong.conf
  3. 创建dockerfile
  4. 创建Upstream, Target, Service, Routes
  5. 为创建的Service添加插件
** handler.lua
#+begin_src lua
  -- hello-world/handler.lua

  local BasePlugin = require "kong.plugins.base_plugin"

  local HelloWorldHandler = BasePlugin:extend()

  function HelloWorldHandler:new()
     HelloWorldHandler.super.new(self, "hello-world")
     ngx.log(ngx.INFO, "========= Hello World: new ====================")
  end

  -- Nginx worker 启动时执行。适用于需要启动时一次性执行的任务
  function HelloWorldHandler:init_worker()
    HelloWorldHandler.super.init_worker(self)
     ngx.log(ngx.INFO, "========= Hello World: init_worker ====================")
  end

  -- SSL 握手提供证书时执行，可以动态的选择和设置证书
  function HelloWorldHandler:certificate(conf)
     HelloWorldHandler.super.certificate(self)
     ngx.log(ngx.INFO, "Hello certificate")
     ngx.log(ngx.INFO, "========= Hello World: certificate ====================")
     -- 示例：设置证书。这需要更复杂的实现和配置。
     -- kong.ssl.set_cert_and_key(cert, ke
  end

  -- 客户端接收到请求，进入rewrite阶段时执行。只有配置成全局插件时才执行。此阶段不可读取请求体
  function HelloWorldHandler:rewrite(conf)
     HelloWorldHandler.super.rewrite(self)
     ngx.log(ngx.INFO, "========= Hello World: rewrite ====================")
     -- 示例：改写URI
     -- kong.service.request.set_path("/new-path")
  end

  -- 在代理请求到上游之前，用于执行鉴权，读取/修改 请求头，查询参数等操作
  function HelloWorldHandler:access(conf)
     HelloWorldHandler.super.access(self)
     kong.response.set_header("Hello-Access", "World")
     ngx.log(ngx.INFO, "========= Hello World: access ====================")
  end

  -- 从上游接收到响应头，返回到客户端之前，可以用来修改响应头
  function HelloWorldHandler:header_filter(conf)
     HelloWorldHandler.super.header_filter(self)
     kong.response.set_header("Hello-Header-Filter", "World")
     ngx.log(ngx.INFO, "========= Hello World: header_filter ====================")
  end

  -- 从上游接收到响应体，返回客户端之前，可以用来读取和修改返回的响应体
  function HelloWorldHandler:body_filter(conf)
     HelloWorldHandler.super.body_filter(self)
     ngx.log(ngx.INFO, "========= Hello World: body_filter ===============")
     -- 示例：改写响应体。在实践中，你需要使用Lua的string库或其他方法处理body。
     -- local body = kong.response.get_body()
     -- body = body:gsub("old-string", "new-string")
     -- kong.response.set_body(body)
  end

  -- 用于记录日志，在请求体完全发送到客户端之后执行
  function HelloWorldHandler:log(conf)
     HelloWorldHandler.super.log(self)
     -- 示例：记录一条消息。实际应用中，你可能想使用外部日志系统。
     ngx.log(ngx.INFO, "========= Hello World: log ====================")
  end

  return HelloWorldHandler
#+end_src
** schema.lua
#+begin_src lua
  -- hello-world/schema.lua

  return {
    no_consumer = true,
    fields = {}
  }
#+end_src
*** 关于schema.lua的配置与作用

  用于配置参数的类型以及约束条件。

  - type: 参数类型
    | 名称        | 说明                     | 举例                                                                                                               |
    |-------------|--------------------------|--------------------------------------------------------------------------------------------------------------------|
    | string      | 字符串                   | { username = { type = "string", required = true } }                                                                |
    | number      | 数字                     | { discount = { type = "number", default = 0.1 } }  -- 10% discount                                                 |
    | boolean     | 布尔值                   | { isActive = { type = "boolean", default = true } }                                                                |
    | integer     | 整数                     | { age = { type = "integer", default = 18 } }                                                                       |
    | array       | 数组                     | { tags = { type = "array", default = { "example", "demo" } } }                                                     |
    | record      | 键值对的集合             | { address = { type = "record", fields = { { city = { type = "string" } }, { zipcode = { type = "integer" } } } } } |
    | map         | 键值对的集合             | { headers = { type = "map", keys = { type = "string" }, values = { type = "string" }}                              |
    | uuid        | 一个符合uuid格式的字符串 | { user_id = { type = "uuid" } }                                                                                    |
    | timestamp   | 时间戳                   | { created_at = { type = "timestamp" } }                                                                            |
    | url         | 有效的URL字符串          | { website = { type = "url" } }                                                                                     |
    | ip          | IPv4或IPv6               | { website = { type = "ip" } }                                                                                      |
    | cidr        | 有效的CIDR表示法的子网   | { website = { type = "cidr" } }                                                                                    |
    | port        | 一个有效的网络端口号     | { service_port = { type = "port" } }                                                                               |
    | foreign     | 外部键的关系             | { consumer = { type = "foreign", reference = "consumers" } }                                                       |
    | header_name | 有效的HTTP头             | { custom_header = { type = "header_name" } }                                                                       |
    | cookie_name | 有效的Cookie名           | { session_cookie = { type = "cookie_name" } }                                                                      |
  - required: 是否必须
  - default: 默认值
  - pattern: 为字符串设置正确的正则表达式
  - enum: 限制字段值只能从列表中选择

#+begin_src lua
  local typedefs = require "kong.db.schema.typedefs"

  return {
    name = "my-plugin",
    fields = {
      {
        config = {
          type = "record",
          fields = {
            -- 使用pattern确保api_key以"key-"开头
            { api_key = { type = "string", required = true, pattern = "^key-.*" } },
            { rate_limit = { type = "number", default = 100 } },
            { enabled = { type = "boolean", default = true } },
            -- 使用enum限制log_level只能为下列值之一
            { log_level = { type = "string", enum = { "info", "warning", "error" } } },
          },
        },
      },
    },
  }
#+end_src

** daos.lua
定义数据库访问对象的列表
#+begin_src lua
  -- daos.lua
  return {
    apikeys = {
      primary_key = {"id"},
      fields = {
        { id = { type = "uuid", required = true, auto = true } },
        { key = { type = "string", required = true, unique = true } },
        { created_at = { type = "integer", required = true, auto = true } },
      }
    }
  }
#+end_src

** migrations/*.lua
数据源迁移，只有当用户的插件有自定义实体时才需要。这个目录包含数据库迁移脚本，用于初始化或修改插件使用的数据库结构。当你的插件的数据结构变更时(例如添加、删除或修改字段)，你会需要创建新的迁移来处理这些变更。
#+begin_src lua
  -- migrations/0001_init_apikeys.lua
  return {
    up = [[
      CREATE TABLE apikeys (
        id UUID PRIMARY KEY,
        key TEXT UNIQUE,
        created_at TIMESTAMP
      );
    ]],
    down = [[
      DROP TABLE apikeys;
    ]]
  }
#+end_src
** api.lua
定义Admin API中的端点列表，与插件自定义实体进行交互
#+begin_src lua
  -- api.lua
  return {
    ["/apikeys/:key"] = {
      GET = function(self, dao_factory, helpers)
        local apikey, err = dao_factory.apikeys:find({
          key = self.params.key
        })
        if err then
          return helpers.responses.send_HTTP_INTERNAL_SERVER_ERROR(err)
        end
        if not apikey then
          return helpers.responses.send_HTTP_NOT_FOUND()
        end
        return helpers.responses.send_HTTP_OK(apikey)
      end
    }
  }
#+end_src
** kong.conf
#+begin_src conf
plugins = bundle,hello-world
#+end_src
** dockerfile
#+begin_src dockerfile
  FROM kong:latest

  RUN date

  USER root
  RUN luarocks install kong-plugin-hello-world

  COPY ./hello-world /usr/local/share/lua/5.1/kong/plugins/hello-world
  COPY ./kong.conf /etc/kong/

  RUN luarocks install pgmoon
#+end_src
#+begin_src shell
  sudo docker build -t kong-with-hello-world .
#+end_src

** Upstream Target && Service Routes
#+begin_src shell
  KONG_HOST=192.168.3.124:8001 # kong admin的端口
  UPSTREAM_NAME=testUp
  SERVICE_NAME=testSvc
  ROUTE_NAME=testRoute
  HOST_NAME=kong.inmove.top

  # 添加upstream
  curl -i -X POST --url http://${KONG_HOST}/upstreams --data name=${UPSTREAM_NAME}

  # 为upstream添加target
  curl -i -X POST --url http://${KONG_HOST}/upstreams/${UPSTREAM_NAME}/targets --data target=192.168.3.131:8000

  curl -i -X POST --url http://${KONG_HOST}/upstreams/${UPSTREAM_NAME}/targets --data target=192.168.3.132:8000

  # 为service设置upstream
  curl -i -X POST --url http://${KONG_HOST}/services --data name=${SERVICE_NAME} --data url=http://${UPSTREAM_NAME}

  # 设置路由
  curl -i -X POST --url http://${KONG_HOST}/services/${SERVICE_NAME}/routes --data hosts[]=${HOST_NAME} --data name=${ROUTE_NAME}

#+end_src
#+begin_src conf
  # 对应于添加upstream与targets
  upstream task_manager {
      server knode01:31406;
      server knode02:31406;
      server knode03:31406;
  }

  server {
      # 对应于设置路由
      server_name example.com;

      location / {
          # 对应于为service设置upstream
          proxy_pass http://task_manager;
      }
  }
#+end_src
** 添加插件到Service
#+begin_src shell
  # 查看所有service
  curl -X GET http://127.0.0.1:8001/services
  # 找到service对应的id，为其添加一个 plugin
  curl -X POST http://127.0.0.1:8001/services/${SERVICE_ID}/plugins -d "name=hello-world"
#+end_src
