#+TITLE: C语言的灵魂 - 指针
#+DATE: 2023-10-17 23:23:45
#+DISPLAY: t
#+STARTUP: indent
#+OPTIONS: toc:10
#+AUTHOR: inmove
#+KEYWORDS: 指针
#+CATEGORIES: C

* C语言的灵魂 - 指针
#+begin_src c
  #include <stdlib.h>
  #include <stdio.h>

  typedef struct task_s {
      char value;
      struct task_s *next;
      char b;
  } task_t;

  int main() {
      /**
         定义一个变量叫head，该变量存在于栈上
           &head 是栈上的地址
           ,*head 则是在堆上分配的地址 同时 *head 也是head中存储的值
       ,*/
      task_t *head = (task_t *)malloc(sizeof(task_t));
      task_t h = *head;  // 将堆中的内容复制到了栈上
      int a = 10;
      printf("head是一个变量名，它存在于栈上: %p\n", &head);
      printf("head的值是一个地址，它是堆上的一个地址: %p\n", head);
      printf("h是一个变量名，它存在于栈上: %p\n", &h);
      printf("h是复制了head在堆上的内容: %d\n", h.value);
      printf("*head只是一个堆上的地址，所以其大小为指针的大小: %ld\n", sizeof(*head));
      printf("h *head中的内容，也就是说h把head所指向的内容从堆上复制到了栈上: %ld\n", sizeof(h));
      printf("h占用了16个字节(struct task_t的大小), 所以 h的地址与a的地址差了16个字节(实际输出为12，看下面两行输出): %p, %p, %ld, %ld\n", &h, &a, (void *)&h - (void *)&a, sizeof(h));
      printf("a在栈上的地址: %p, head在栈上的地址: %p, h在栈上的地址: %p\n", &a, &head, &h);
      printf("栈是从底往上(从小到大)分配，可以看到 a在head的下面，head在h的下面，也就是说这里编译器做了内存的优化");
      return 0;
  }

#+end_src

** 函数指针
#+begin_src c
  #include <stdlib.h>
  #include <stdio.h>

  /**
     相当于为 int *f(int, int) 定义了一个别名
   ,*/
  typedef int (*MyFunc)(int, int);

  int func(int, int);

  int func(int a, int b) {
      return a + b;
  }

  int main() {
      printf("%p\n", &func);

      MyFunc f = func;
      f(1, 2);

      return 0;
  }
#+end_src

** 指针的指针

可以这样看，我们写的代码都是给编译器看的。
当我们定义一个指针变量的时候：
  =int *p= ，在编译器看来，p是一个变量，它的值是一个地址。
  =int **p= ，p是一个变量，它的值是一个地址，它的值所指向的地址的值也是一个地址
  另外有一种写法 =*(char **)p = ptr= ，p本身是个一级指针，将它强转为一个二级指针，这样，它指向的地址的值也可以用来存储一个地址。

#+begin_src c
  #include <stdio.h>
  #include <stdlib.h>

  /**

      +-----------------------------+
      | Address | Value(or Address) |
      +-----------------------------+


     栈


     +---------------+
     |arr  | array   |   将h传给了函数，所以arr的值也是指向 array的地址的。
     +---------------+   *arr 叫解引用，相当于顺着 arr的值找到那个变量

           ^
           |

     +---------------+
     | h   | array   |   在栈上定义了另一个指针变量，名称为h，值为array的地址
     +---------------+

           ^
           |

     +---------------+
     |array| NULL    |   在栈上定义了一个指针变量，名称为array，值为NULL
     +---------------+


   ,*/

  void allocateArray(int **arr, int size) {
      printf("%p\n", &(*arr));
      ,*arr = malloc(size * sizeof(int));
  }

  int main() {
      int *array = NULL;
      int **h = &array;
      printf("%p\n", &array);
      printf("%p\n", &h);
      printf("%p\n", &(*h));
      allocateArray(h, 5);
      free(array);
      return 0;
  }
#+end_src
