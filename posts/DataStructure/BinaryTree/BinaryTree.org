#+TITLE: 什么是二叉树以及一些基础函数
#+DATE: 2023-09-28 00:10:26
#+DISPLAY: t
#+STARTUP: indent
#+OPTIONS: toc:10
#+AUTHOR: inmove
#+KEYWORDS: 二叉树 数据结构
#+CATEGORIES: 二叉树 数据结构

* 二叉树

  二叉树是一种特殊的树结构，其中每个节点最多有两个子节点，通常称为“左子节点”和“右子节点”。以下是二叉树的一些基本性质:
  1. 最大节点数: 在深度为d的二叉树中，最大节点数为 2^d - 1
  2. 最小深度: n个结点的二叉树中，最小深度为 ⌈log(n+1)⌉。完全二叉树
  3. 最大深度: n个结点的二叉树，最大深度为n，退化为链表的时候
  4. 叶节点: 没有子节点的节点称为叶节点。如果度为2的节点个数为D，那么叶节点的个数 L = D + 1
  5. 完全二叉树: 除最后一层外，每一层的上的节点数均达到最大值
  6. 满二叉树: 每一层的节点数，都达到最大值

* 打印二叉树
#+begin_src python
  class Bcolors:

      HEADER = '\033[95m'
      OKBLUE = '\033[94m'
      OKGREEN = '\033[92m'
      WARNING = '\033[93m'
      FAIL = '\033[91m'
      ENDC = '\033[0m'
      BOLD = '\033[1m'
      UNDERLINE = '\033[4m'

      BLACK_FONT_C = "\033[30m"
      RED_FONT_C = "\033[31m"
      GREEN_FONT_C = "\033[32m"
      YELLOW_FONT_C = "\033[33m"
      DARK_BLUE_FONT_C = "\033[34m"
      PINK_FONT_C = "\033[35m"
      LIGHT_BLUE_FONT_C = "\033[36m"
      LIGHT_GREY_FONT_C = "\033[90m"
      ORIGIN_FONT_C = "\033[91m"

      @classmethod
      def color_value(cls, color, value):
          return color + str(value) + cls.ENDC

      @classmethod
      def red_value(cls, value):
          return cls.color_value(cls.RED_FONT_C, value)

      @classmethod
      def green_value(cls, value):
          return cls.color_value(cls.GREEN_FONT_C, value)


  class DisplayTree:

      def __init__(self, tree):
          self.tree = tree
          self._under_score = "_"
          self._back_slash = "\\"
          self._slash = "/"
          self._space = " "

      def display(self):
          """
          打印一棵二叉树
          https://stackoverflow.com/questions/34012886/print-binary-tree-level-by-level-in-python
          """
          if self.tree.root is None:
              return
          lines, *_ = self._display_aux(self.tree.root)
          for line in lines:
              print(line)

      def __get_node_color_key(self, node):
          if hasattr(node, "color_key"):
              return str(node.color_key)
          return str(node.key)

      def __set_node_color_key(self, node, color):
          if hasattr(node, "color_key"):
              node.color_key = color

      def __get_node_length(self, node):
          if hasattr(node, "length"):
              return node.length
          return len(str(node.key))

      def _display_aux(self, node):
          """
          参数:
              node: 起始结点
          返回值:
              [line]: 文字内容
              width: 所有文字内容一共占多少字符
              height: 结点高度
              middle: 要为子结点付出多少位置
          """
          if node is None:
              return
          # No child.
          if node.right is None and node.left is None:
              line = self.__get_node_color_key(node)
              width = self.__get_node_length(node)
              height = 1
              middle = width // 2
              return [line], width, height, middle

          self.__set_node_color_key(node, None)

          # Only left child.
          if node.right is None:
              lines, n, p, x = self._display_aux(node.left)
              s = self.__get_node_color_key(node)
              u = self.__get_node_length(node)
              first_line = (x + 1) * self._space + (n - x - 1) * self._under_score + s
              second_line = x * self._space + self._slash + (n - x - 1 + u) * self._space
              shifted_lines = [line + u * self._space for line in lines]
              return [first_line, second_line] + shifted_lines, n + u, p + 2, n + u // 2

          # Only right child.
          if node.left is None:
              lines, n, p, x = self._display_aux(node.right)
              s = self.__get_node_color_key(node)
              u = self.__get_node_length(node)
              first_line = s + x * self._under_score + (n - x) * self._space
              second_line = (u + x) * self._space + self._back_slash + (n - x - 1) * self._space
              shifted_lines = [u * self._space + line for line in lines]
              return [first_line, second_line] + shifted_lines, n + u, p + 2, u // 2

          # Two children.
          left, n, p, x = self._display_aux(node.left)
          right, m, q, y = self._display_aux(node.right)
          s = self.__get_node_color_key(node)
          u = self.__get_node_length(node)
          first_line = (x + 1) * self._space + (n - x - 1) * self._under_score + s + y * self._under_score + (m - y) * self._space
          second_line = x * self._space + self._slash + (n - x - 1 + u + y) * self._space + self._back_slash + (m - y - 1) * self._space
          if p < q:
              left += [n * self._space] * (q - p)
          elif q < p:
              right += [m * self._space] * (p - q)
          zipped_lines = zip(left, right)
          lines = [first_line, second_line] + [a + u * self._space + b for a, b in zipped_lines]
          return lines, n + m + u, max(p, q) + 2, n + u // 2
#+end_src
#+begin_src shell
                                      ______________________________141_________________________________
                                     /                                                                  \
              ______________________82___________                                   ___________________172____________
             /                                   \                                 /                                  \
        ____26___________                   ____99_____                      _____148____________               _____189_____
       /                 \                 /           \                    /                    \             /             \
     _11__          ____62_____          _88__       _122_____            _146__           _____165__        _175__        _190_____
    /     \        /           \        /     \     /         \          /      \         /          \      /      \      /         \
  -999  -999     _57__       _64__    -999  -999  -999      _129__     -999   -999      _158__     -999   -999   -999   -999      _193__
                /     \     /     \                        /      \                    /      \                                  /      \
              -999  -999  -999  -999                     -999   -999                 -999   -999                               -999   -999
                               __________________________________________124________________________________________
                              /                                                                                     \
             ________________53_______________________                                          ___________________177_____
            /                                         \                                        /                           \
       ____16_____                         __________92____________               ____________143_____                   _181_____
      /           \                       /                        \             /                    \                 /         \
     _4__       _32_____             ____77_____             _____113__        _132_____            _151_____         -999      _186__
    /    \     /        \           /           \           /          \      /         \          /         \                 /      \
  -999 -999  -999     _34__       _70__       _78__       _105__     -999   -999      _142__     -999      _171__            -999   -999
                     /     \     /     \     /     \     /      \                    /      \             /      \
                   -999  -999  -999  -999  -999  -999  -999   -999                 -999   -999          -999   -999

#+end_src

* 二叉树的遍历
#+begin_src python
  from collections import deque

  def morrisIn(root):
      result = []
      n1, n2 = root, None
      while n1 is not None:

          # 因为是先序遍历，所以先处理左子结点
          if n1.left is not None:
              # 找到左子结点的最右结点，也就是当前结点直接前驱
              n2 = n1.left
              while n2.right and n2.right != n1:
                  n2 = n2.right

              # 如果直接前驱的右儿子是None，则让他指向当前结点
              if n2.right is None:
                  n2.right = n1
                  # 开始处理左子结点
                  n1 = n1.left
                  continue
              else:
                  # 直接前驱的右儿子不是None，指向的一定是当前结点
                  n2.right = None
          # 处理当前结点
          result.append(str(n1.key))
          # 处理右子结点
          # 处理左子结点的最右结点时，n1重新指向了当前结点!!!
          #       A
          #      /!\
          #     B ! C
          #    / \!
          #   D   E
          # 此时E是指向A的。当n1指向E的时候 n1 = n1.right 会使 n1指向A
          n1 = n1.right
      return ",".join(result)

  def morrisPre(root):
      result = []
      n1, n2 = root, None
      while n1 is not None:
          if n1.left is not None:
              n2 = n1.left
              while n2.right and n2.right != n1:
                  n2 = n2.right
              if n2.right is None:
                  n2.right = n1
                  # 要处理左儿子前先把当前结点处理掉
                  result.append(str(n1.key))
                  n1 = n1.left
                  continue
              else:
                  n2.right = None
          else:
              # 没有左儿子，直接处理当前结点
              result.append(str(n1.key))
          # 处理右儿子
          n1 = n1.right
      return ",".join(result)

  def morrisPost(root):

      """
      后序遍历顺序是 左 - 右 - 中
      换种说法就是 每个结点的左儿子进行右边界 逆序遍历

                       A
                      / \
                     B   C
                    / \
                   D   E
      后序为 D E B C A
      假设有一条从左上到右下的斜线，斜线每走一步，就从下往上遍历压到的结点
      最开始是到D
      然后是 B E
      最后是 A C
      所以collect函数是搜集右子树的倒序
      """

      def reverseEdge(node):
          pre, next = None, None
          while node is not None:
              next = node.right
              node.right = pre
              pre = node
              node = next
          return pre

      def collect(node):
          tail = reverseEdge(node)
          cur = tail
          while cur is not None:
              result.append(str(cur.key))
              cur = cur.right
          reverseEdge(tail)

      result = []
      n1, n2 = root, None
      while n1 is not None:
          if n1.left is not None:
              n2 = n1.left
              while n2.right and n2.right != n1:
                  n2 = n2.right
              if n2.right is None:
                  n2.right = n1
                  n1 = n1.left
                  continue
              else:
                  n2.right = None
                  # 收集左儿子以及左儿子的右子树
                  collect(n1.left)
          n1 = n1.right
      # 收集根以及根的右子树
      collect(root)
      return ",".join(result)

  def printReverse(fromNode, toNode, result):
      """
      Print the nodes from fromNode to toNode in reverse order
      """
      reverseNodes = []
      while fromNode != toNode:
          reverseNodes.append(fromNode)
          fromNode = fromNode.right
      reverseNodes.append(toNode)
      while reverseNodes:
          result.append(str(reverseNodes.pop().key))

  def morrisPost(root, cls):
      dummy = cls(0)
      dummy.left = root
      current = dummy

      result = []
      while current is not None:
          if current.left is None:
              current = current.right
          else:
              pre = current.left
              while pre.right is not None and pre.right != current:
                  pre = pre.right

              if pre.right is None:
                  pre.right = current
                  current = current.left
              else:
                  printReverse(current.left, pre, result)
                  pre.right = None
                  current = current.right
      return ",".join(result)

  def inorder(root):
      """中序遍历二叉树"""
      result = []

      def process(root):
          if root is None:
              return
          process(root.left)
          result.append(str(root.key))
          process(root.right)
      process(root)
      return ",".join(result)

  def inorderStack(root):
      if root is None:
          return
      result = []
      stack = []
      while root or stack:
          while root:
              stack.append(root)
              root = root.left
          root = stack.pop()
          result.append(str(root.key))
          root = root.right
      return ",".join(result)

  def preorder(root):

      result = []

      def process(root):
          if root is None:
              return
          result.append(str(root.key))
          process(root.left)
          process(root.right)
      process(root)
      return ",".join(result)

  def preorderStack(root):
      if root is None:
          return
      result = []
      stack = [root]
      while stack:
          node = stack.pop()
          result.append(str(node.key))
          if node.right:
              stack.append(node.right)
          if node.left:
              stack.append(node.left)
      return ",".join(result)

  def postorder(root):

      result = []

      def process(root):
          if root is None:
              return
          process(root.left)
          process(root.right)
          result.append(str(root.key))

      process(root)

      return ",".join(result)

  def postorderStack(root):
      if root is None:
          return []
      stack1, stack2 = [root], []
      result = []
      while stack1:
          node = stack1.pop()
          stack2.append(node)
          if node.left:
              stack1.append(node.left)
          if node.right:
              stack1.append(node.right)
      while stack2:
          result.append(str(stack2.pop().key))
      return ",".join(result)

  def levelorderTwoStack(root):
      """层序遍历"""
      result = []
      stack = []
      stack.append(root)

      while stack:
          tmpStack = []
          while stack:
              tmpStack.append(stack.pop())
          while tmpStack:
              node = tmpStack.pop()
              if node.left:
                  stack.append(node.left)
              if node.right:
                  stack.append(node.right)
              result.append(str(node.key))
      return ",".join(result)

  def levelorderQueue(root):
      queue = deque([root])
      result = []
      while queue:
          node = queue.popleft()
          result.append(str(node.key))
          if node.left:
              queue.append(node.left)
          if node.right:
              queue.append(node.right)
      return ",".join(result)

  def levelorderBottom(root, guard):
      if not root:
          return []
      queue = deque()
      result = []
      queue.append(root)
      while queue:
          queue.append(guard)
          result.append([])
          while queue:
              node = queue.popleft()
              if node == guard:
                  break
              result[-1].append(node.key)
              if node.left:
                  queue.append(node.left)
              if node.right:
                  queue.append(node.right)
      result = list(reversed(result))
      return result
#+end_src
* 判断是否是二叉搜索树
#+begin_src python
  from typing import Optional

  class TreeNode:
      def __init__(self, val=0, left=None, right=None):
          self.val = val
          self.left = left
          self.right = right

  class Solution:
      def isValidBST(self, root: Optional[TreeNode]) -> bool:
          return self.isValidBSTRecusive(root, float('-inf'), float('inf'))

      def isValidBSTRecusive(self, root: TreeNode, minValue: float, maxValue: float) -> bool:
          if root is None:
              return True
          if not (minValue < root.val < maxValue):
              return False
          return self.isValidBSTRecusive(root.left, minValue, root.val) and \
              self.isValidBSTRecusive(root.right, root.val, maxValue)

      def isValibBST2(self, root: Optional[TreeNode]) -> bool:
          """ 利用中序递归, 记录前一个结点的值，每遍历到一个结点时和前一个结点值进行对比
          """
          if not root:
              return True
          stack = []
          pre = float('-inf')
          while root or stack:
              while root:
                  stack.append(root)
                  root = root.left
              root = stack.pop()
              if root.val <= pre:
                  return False
              root = root.right
          return True
#+end_src
* 二叉树中最大路径和
#+begin_src python
  from typing import Optional

  class TreeNode:
      def __init__(self, val=0, left=None, right=None):
          self.val = val
          self.left = left
          self.right = right

  class Solution:

      def maxPathSum(self, root: Optional[TreeNode]) -> int:
          self.max_sum = -float('inf')
          self.maxPathSumRecu(root)
          return self.max_sum

      def maxPathSumRecu(self, root):
          if root is None:
              return 0
          # 计算左子树的最大路径和
          maxLeft = max(0, self.maxPathSumRecu(root.left))
          # 计算左子树的最大路径和
          maxRight = max(0, self.maxPathSumRecu(root.right))
          # 当前结点，左右子树，三者之和作为最大路径和，与已保存的最大路径和做比较
          self.max_sum = max(self.max_sum, maxLeft + maxRight + root.val)
          # 返回给当前结点父结点计算最大路径和(只能使用左子树或右子树中的一个结点)
          return root.val + max(maxLeft, maxRight)
#+end_src
