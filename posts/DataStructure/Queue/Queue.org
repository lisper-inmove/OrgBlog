#+TITLE: 队列
#+DATE: 2023-09-28 00:27:14
#+DISPLAY: t
#+STARTUP: indent
#+OPTIONS: toc:10
#+AUTHOR: inmove
#+KEYWORDS: 数据结构 队列
#+CATEGORIES: 队列 数据结构

* 队列
  队列是一种先入先出数据结构。就像排队买票一样，排在前面的先被执行。比较常用的一种队列是优先级队列。常用于任务调度。
  常见的操作如下:
  1. empty: 判空
  2. full: 判满
  3. enqueue(item): 入队
  4. dequeue: 出队
  5. peekHead: 查看队首
  6. peekTail: 查看队尾

* 循环队列
#+begin_src python
  class CircleQueue:

      def __init__(self, capacity):
          self.capacity = capacity
          self.curSize = 0
          self.items = [float('inf')] * capacity
          self._head = 0 # 下一个出队时的索引
          self._tail = 0 # 下一个入队时的索引

      def enqueue(self, item):
          if self.isFull():
              raise Exception("队满")
          self.items[self._tail % self.capacity] = item
          self._tail = (self._tail + 1) % (self.capacity)
          self.curSize += 1

      def dequeue(self):
          if self.isEmpty():
              raise Exception("队空")
          item = self.items[self._head]
          self.items[self._head] = float('inf')
          self._head = (self._head + 1) % (self.capacity)
          self.curSize -= 1
          return item

      def peekHead(self):
          if self.isEmpty():
              raise Exception("队空")
          item = self.items[self._head]
          return item

      def peekTail(self):
          if self.isEmpty():
              raise Exception("队空")
          if self._tail == 0:
              return self.items[self.capacity - 1]
          return self.items[self._tail - 1]

      def isFull(self):
          return self.curSize == self.capacity

      def isEmpty(self):
          return self.curSize == 0

      def __str__(self):
          return f"{self._head} - {self._tail} - {self.items}"


  class DoubleEndQueue:

      def __init__(self, capacity):
          self.capacity = capacity
          self.items = [float('inf')] * self.capacity
          self.curSize = 0
          self._tail = 0
          self._head = capacity - 1

      def enqueue(self, item, tail=True):
          if self.isFull():
              raise Exception("队满")
          if tail:
              return self.__tailEnqueue(item)
          return self.__headEnqueue(item)

      def __tailEnqueue(self, item):
          self.items[self._tail % self.capacity] = item
          self._tail = (self._tail + 1) % (self.capacity)
          self.curSize += 1

      def __headEnqueue(self, item):
          index = self._head % self.capacity
          self.items[index] = item
          self._head -= 1
          if self._head == -1:
              self._head = self.capacity - 1
          self.curSize += 1

      def dequeue(self, tail=True):
          if self.isEmpty():
              raise Exception("栈空")
          self.curSize -= 1
          if tail:
              return self.__tailDequeue()
          return self.__headDequeue()

      def __tailDequeue(self):
          item = self.peekTail()
          self._tail -= 1
          if self._tail == -1:
              self._tail = self.capacity - 1
          self.items[self._tail] = float('inf')
          return item

      def __headDequeue(self):
          item = self.peekHead()
          self._head = (self._head + 1) % self.capacity
          self.items[self._head] = float('inf')
          return item

      def peekHead(self):
          head = (self._head + 1) % self.capacity
          return self.items[head]

      def peekTail(self):
          tail = self._tail - 1
          if tail == -1:
              tail = self.capacity - 1
          return self.items[tail]

      def isFull(self):
          return self.curSize == self.capacity

      def isEmpty(self):
          return self.curSize == 0

      def __str__(self):
          return f"{self._head} - {self._tail} - {self.items}"


  if __name__ == '__main__':
      values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

      print("######### 循环队列测试 ###################")
      queue = CircleQueue(8)
      for value in values:
          queue.enqueue(value)
          if value in (4, 2, 7):
              queue.dequeue()
          print(queue)
      print(queue.peekHead())
      print(queue.peekTail())

      print("######### 双端循环队列测试 ###################")
      dqueue = DoubleEndQueue(8)
      for i in range(0, 3):
          dqueue.enqueue(values[i])
      for i in range(3, 5):
          dqueue.enqueue(values[i], tail=False)
      for i in range(6, 10):
          try:
              dqueue.enqueue(values[i], tail=False)
          except:
              break
      print(dqueue)

      dqueue.dequeue()
      dqueue.dequeue(tail=False)
      print(dqueue)
#+end_src
