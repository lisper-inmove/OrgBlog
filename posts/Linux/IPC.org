#+TITLE: 进程间通信
#+DATE: 2023-10-20 01:32:03
#+DISPLAY: t
#+STARTUP: indent
#+OPTIONS: toc:10
#+AUTHOR: inmove
#+KEYWORDS: IPC pipe FIFO
#+CATEGORIES: Linux

* pipe

=int pipe(int pipefd[2]);=

pipefd[0] 用于读
pipefd[1] 用于写
通常在父子进程中用于通信。一个进程中关闭读，另一个进程中关闭写。
在关闭读的那个进程中写，在关闭写的那个进程中可以读出来。

#+begin_src c
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <string.h>

  typedef struct {
      int id;
      char name[256];
  } Person;

  int main() {
      int fd[2];
      pid_t pid;
      Person p_send = {1, "Inmove"};
      Person p_recv;

      // 创建管道
      if (pipe(fd) < 0) {
          perror("pipe error");
          exit(1);
      }

      // 创建子进程
      pid = fork();
      if (pid < 0) {
          perror("fork error");
          exit(1);
      }

      if (pid > 0) {  // 父进程
          close(fd[0]);  // 关闭读端
          // 将结构体写入管道
          write(fd[1], &p_send, sizeof(Person));
          close(fd[1]);  // 关闭写端
      } else {  // 子进程
          close(fd[1]);  // 关闭写端
          // 从管道中读取结构体
          read(fd[0], &p_recv, sizeof(Person));
          printf("Received Person: id=%d, name=%s\n", p_recv.id, p_recv.name);
          close(fd[0]);  // 关闭读端
      }

      return 0;
  }

#+end_src

* popen and pclose

=FILE *popen(const char *cmdstring, const char *type)=
=int pclose(FILE *fp)=

popen先执行fork，然后调用exec执行cmdstring，并且返回一个标准的I/O文件指针。
如果type是 'r' 则连接到cmdstring的标准输出，表示父进程从子进程读。
如果是 'w' 则连接到cmdstring的标准输入，表示父进程往子进程写。
#+begin_src c
  #include <stdio.h>
  #include <stdlib.h>

  int main() {
      FILE *fp;
      char buffer[256];

      // 使用 popen() 创建一个子进程执行 "ls" 命令
      if ((fp = popen("ls", "r")) == NULL) {
          perror("popen error");
          exit(1);
      }

      // 读取 "ls" 命令的输出
      while (fgets(buffer, sizeof(buffer), fp) != NULL) {
          printf("%s", buffer);
      }

      // 使用 pclose() 关闭管道
      if (pclose(fp) == -1) {
          perror("pclose error");
          exit(1);
      }

      return 0;
  }
#+end_src
